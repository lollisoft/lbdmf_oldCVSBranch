<xsl:stylesheet version="1.0" xmlns:xsl="http://www.w3.org/1999/XSL/Transform" xmlns:exsl="http://exslt.org/common" extension-element-prefixes="exsl">
<!--
    DMF Distributed Multiplatform Framework (the initial goal of this library)
    This file is part of lbDMF.
    Copyright (C) 2002-2009  Lothar Behrens (lothar.behrens@lollisoft.de)

    This library is free software; you can redistribute it and/or
    modify it under the terms of the GNU Lesser General Public
    License as published by the Free Software Foundation; either
    version 2.1 of the License, or (at your option) any later version.

    This library is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
    Lesser General Public License for more details.

    You should have received a copy of the GNU Lesser General Public
    License along with this library; if not, write to the Free Software
    Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA


    The author of this work will be reached by e-Mail or paper mail.
    e-Mail: lothar.behrens@lollisoft.de
    p-Mail: Lothar Behrens
            Ginsterweg 4
            
            65760 Eschborn (germany)
-->
<!-- Helper to create multible files. -->
<xsl:import href="../include/exsl.xsl"/>

<xsl:import href="../include/lbDMFBaseTemplates.xsl"/>

<!-- The database panel file per formular -->
<xsl:import href="wxLuaDatabasePanel.xsl"/>

<xsl:variable name="OrginalApplicationName" select="//lbDMF/applications/application[@ID=$ApplicationID]/@name"/>
<xsl:variable name="ApplicationName">
	<xsl:call-template name="SubstringReplace">
		<xsl:with-param name="stringIn">
	<xsl:call-template name="SubstringReplace">
		<xsl:with-param name="stringIn">
	<xsl:call-template name="SubstringReplace">
		<xsl:with-param name="stringIn">
			<xsl:value-of select="$OrginalApplicationName"/>
		</xsl:with-param>
		<xsl:with-param name="substringIn" select="'-'"/>
		<xsl:with-param name="substringOut" select="''"/>
	</xsl:call-template>
		</xsl:with-param>
		<xsl:with-param name="substringIn" select="'>'"/>
		<xsl:with-param name="substringOut" select="''"/>
	</xsl:call-template>
		</xsl:with-param>
		<xsl:with-param name="substringIn" select="' '"/>
		<xsl:with-param name="substringOut" select="''"/>
	</xsl:call-template>
</xsl:variable>



<xsl:template name="createApplicationHeader">
		<xsl:param name="ApplicationID"/>

<exsl:document href="{$basedir}/{$appmoduledir}/{$ApplicationName}_AppModule/{$ApplicationName}.h" method="text">
/* This file is autogenerated. Please do not modify. It would be overwritten.
 */

</exsl:document>
</xsl:template>

<xsl:template name="createApplicationModule">
		<xsl:param name="ApplicationID"/>

<exsl:document href="{$basedir}/{$appmoduledir}/{$ApplicationName}_AppModule/{$ApplicationName}.bat" method="text">
set path=C:\lbDMF;C:\lbDMF\Develop\Projects\dll
lua51 <xsl:value-of select="$ApplicationName"/>.lua
</exsl:document>
		
<exsl:document href="{$basedir}/{$appmoduledir}/{$ApplicationName}_AppModule/{$ApplicationName}.lua" method="text">
--[[-------------------------------------------------------- -*- LUA -*- ----
  Name:        application.lua
  Purpose:     Book Worm App
  Author:      Hakki Dogusan
  Modified by:
  Created:     2006-12-30
  Copyright:   (c) 2007 Hakki Dogusan (http://www.dynaset.org/dogusanh)
  License:     wxWidgets (http://www.opensource.org/licenses/wxwindows.php)
  RCS-ID:      $Id: wxLuaApplicationModul.xsl,v 1.4 2012/04/23 06:06:31 lollisoft Exp $

  Comment:     This file is autogenerated. It would be overwritten.
-]]--------------------------------------------------------------------------

-- package.path = package.path..";/lbDMF/Code/Targets/lbDMF/Modules/TemplateDesigner_AppModule/?.lua;./?.dll;./?.so;../lib/?.so;../lib/vc_dll/?.dll;../lib/bcc_dll/?.dll;../lib/mingw_dll/?.dll;"
-- require("wx")
package.cpath = package.cpath..";../../../../../Develop/projects/dll/?.dll;./?.dll;./?.so;../lib/?.so;../lib/vc_dll/?.dll;../lib/bcc_dll/?.dll;../lib/mingw_dll/?.dll;"
wx = require("ds289u") 
require("wxLuaHelper")


<xsl:for-each select="formulare/formular[@applicationid=$ApplicationID]">
<xsl:variable name="tempFormularName" select="@name"/>
<xsl:variable name="FormularName">
	<xsl:call-template name="SubstringReplace">
		<xsl:with-param name="stringIn">
	<xsl:call-template name="SubstringReplace">
		<xsl:with-param name="stringIn">
	<xsl:call-template name="SubstringReplace">
		<xsl:with-param name="stringIn">
			<xsl:value-of select="$tempFormularName"/>
		</xsl:with-param>
		<xsl:with-param name="substringIn" select="'-'"/>
		<xsl:with-param name="substringOut" select="''"/>
	</xsl:call-template>
		</xsl:with-param>
		<xsl:with-param name="substringIn" select="'>'"/>
		<xsl:with-param name="substringOut" select="''"/>
	</xsl:call-template>
		</xsl:with-param>
		<xsl:with-param name="substringIn" select="' '"/>
		<xsl:with-param name="substringOut" select="''"/>
	</xsl:call-template>
</xsl:variable>
require("<xsl:value-of select="$FormularName"/>")
</xsl:for-each>


--/* XPM */
local sample_xpm = {
--/* columns rows colors chars-per-pixel */
"32 32 6 1",
"  c black",
". c navy",
"X c red",
"o c yellow",
"O c gray100",
"+ c None",
--/* pixels */
"++++++++++++++++++++++++++++++++",
"++++++++++++++++++++++++++++++++",
"++++++++++++++++++++++++++++++++",
"++++++++++++++++++++++++++++++++",
"++++++++++++++++++++++++++++++++",
"++++++++              ++++++++++",
"++++++++ ............ ++++++++++",
"++++++++ ............ ++++++++++",
"++++++++ .OO......... ++++++++++",
"++++++++ .OO......... ++++++++++",
"++++++++ .OO......... ++++++++++",
"++++++++ .OO......              ",
"++++++++ .OO...... oooooooooooo ",
"         .OO...... oooooooooooo ",
" XXXXXXX .OO...... oOOooooooooo ",
" XXXXXXX .OO...... oOOooooooooo ",
" XOOXXXX ......... oOOooooooooo ",
" XOOXXXX ......... oOOooooooooo ",
" XOOXXXX           oOOooooooooo ",
" XOOXXXXXXXXX ++++ oOOooooooooo ",
" XOOXXXXXXXXX ++++ oOOooooooooo ",
" XOOXXXXXXXXX ++++ oOOooooooooo ",
" XOOXXXXXXXXX ++++ oooooooooooo ",
" XOOXXXXXXXXX ++++ oooooooooooo ",
" XXXXXXXXXXXX ++++              ",
" XXXXXXXXXXXX ++++++++++++++++++",
"              ++++++++++++++++++",
"++++++++++++++++++++++++++++++++",
"++++++++++++++++++++++++++++++++",
"++++++++++++++++++++++++++++++++",
"++++++++++++++++++++++++++++++++",
"++++++++++++++++++++++++++++++++"
};




-----------------------------------------------------------------------------
local string = string
local tostring = tostring
local tonumber = tonumber
local error = error
local io = io
local os = os

local wx = wx
local GetImage = GetImage
local wxcolour2number = wxcolour2number
local _ = translate
-----------------------------------------------------------------------------
function get_version()
    return "1.11"
end
-----------------------------------------------------------------------------
-- Generate a unique new wxWindowID
local ID_IDCOUNTER = wx.wxID_HIGHEST + 1
local function NewID()
    ID_IDCOUNTER = ID_IDCOUNTER + 1
    return ID_IDCOUNTER
end
-----------------------------------------------------------------------------


-- Formular ID's

<xsl:for-each select="formulare/formular[@applicationid=$ApplicationID]">
<xsl:variable name="tempFormularName" select="@name"/>
<xsl:variable name="FormularName">
	<xsl:call-template name="SubstringReplace">
		<xsl:with-param name="stringIn">
	<xsl:call-template name="SubstringReplace">
		<xsl:with-param name="stringIn">
	<xsl:call-template name="SubstringReplace">
		<xsl:with-param name="stringIn">
			<xsl:value-of select="$tempFormularName"/>
		</xsl:with-param>
		<xsl:with-param name="substringIn" select="'-'"/>
		<xsl:with-param name="substringOut" select="''"/>
	</xsl:call-template>
		</xsl:with-param>
		<xsl:with-param name="substringIn" select="'>'"/>
		<xsl:with-param name="substringOut" select="''"/>
	</xsl:call-template>
		</xsl:with-param>
		<xsl:with-param name="substringIn" select="' '"/>
		<xsl:with-param name="substringOut" select="''"/>
	</xsl:call-template>
</xsl:variable>
local ID_Formular_<xsl:value-of select="$FormularName"/> = NewID()
</xsl:for-each>


local MyFrame = {
    d3 = nil,
    ID_CreateTree = NewID(),
    ID_CreateGrid = NewID(),
    ID_CreatePerspective = NewID(),
    ID_CopyPerspectiveCode = NewID(),
    ID_FirstPerspective = NewID(),

-- Need to add ID's for each form to handle open the panel
<xsl:for-each select="formulare/formular[@applicationid=$ApplicationID]">
<xsl:variable name="tempFormularName" select="@name"/>
<xsl:variable name="FormularName">
	<xsl:call-template name="SubstringReplace">
		<xsl:with-param name="stringIn">
	<xsl:call-template name="SubstringReplace">
		<xsl:with-param name="stringIn">
	<xsl:call-template name="SubstringReplace">
		<xsl:with-param name="stringIn">
			<xsl:value-of select="$tempFormularName"/>
		</xsl:with-param>
		<xsl:with-param name="substringIn" select="'-'"/>
		<xsl:with-param name="substringOut" select="''"/>
	</xsl:call-template>
		</xsl:with-param>
		<xsl:with-param name="substringIn" select="'>'"/>
		<xsl:with-param name="substringOut" select="''"/>
	</xsl:call-template>
		</xsl:with-param>
		<xsl:with-param name="substringIn" select="' '"/>
		<xsl:with-param name="substringOut" select="''"/>
	</xsl:call-template>
</xsl:variable>
    ID_Create<xsl:value-of select="$FormularName"/> = NewID(),
</xsl:for-each>

    m_mgr = nil,
    m_perspectives = nil,
    m_perspectives_menu = nil,
    m_notebook_style = nil,
    m_notebook_theme = nil,


-- Need to declare the panels
<xsl:for-each select="formulare/formular[@applicationid=$ApplicationID]">
<xsl:variable name="tempFormularName" select="@name"/>
<xsl:variable name="FormularName">
	<xsl:call-template name="SubstringReplace">
		<xsl:with-param name="stringIn">
	<xsl:call-template name="SubstringReplace">
		<xsl:with-param name="stringIn">
	<xsl:call-template name="SubstringReplace">
		<xsl:with-param name="stringIn">
			<xsl:value-of select="$tempFormularName"/>
		</xsl:with-param>
		<xsl:with-param name="substringIn" select="'-'"/>
		<xsl:with-param name="substringOut" select="''"/>
	</xsl:call-template>
		</xsl:with-param>
		<xsl:with-param name="substringIn" select="'>'"/>
		<xsl:with-param name="substringOut" select="''"/>
	</xsl:call-template>
		</xsl:with-param>
		<xsl:with-param name="substringIn" select="' '"/>
		<xsl:with-param name="substringOut" select="''"/>
	</xsl:call-template>
</xsl:variable>
    myPanel_<xsl:value-of select="$FormularName"/> = nil,
</xsl:for-each>
}
-- MyFrame.ID_FirstPerspective = MyFrame.ID_CreatePerspective+1000

function MyFrame.InitDb()
    d3 = wxSQLite3Database()
    d3:Open("<xsl:value-of select="$basedir"/>/../../../../../<xsl:value-of select="//applicationparameter/parameter[@name='DBName']/@value"/>.db3")
end
-----------------------------------------------------------------------------
function MyFrame.DoneDb()
    if d3 == nil then
        return
    end
    d3:Close()
    d3 = nil
end


function MyFrame:create(parent, id, title, pos, size, style)
    self.this = wx.wxFrame(wx.NULL,
                        wx.wxID_ANY,
                        wxT("wxLua prototype of <xsl:value-of select="$ApplicationName"/>"),
                        wx.wxDefaultPosition,
                        wx.wxSize(800, 600));
    local this = self.this

    self.InitDb();

    --// tell wxAuiManager to manage this frame
    self.m_mgr = wxaui.wxAuiManager()
    self.m_mgr:SetManagedWindow(this);

    --// set frame icon
    --this:SetIcon(wx.wxIcon(sample_xpm));
    local bitmap = wx.wxBitmap(sample_xpm)
    local icon = wx.wxIcon()
    icon:CopyFromBitmap(bitmap)
    this:SetIcon(icon)
    bitmap:delete()
    icon:delete()

    --// set up default notebook style
    self.m_notebook_style = wxaui.wxAUI_NB_DEFAULT_STYLE + wxaui.wxAUI_NB_TAB_EXTERNAL_MOVE + wx.wxNO_BORDER;
    self.m_notebook_theme = 0;

    --// create menu
    local mb = wx.wxMenuBar();

    local file_menu = wx.wxMenu();
    file_menu:Append(wx.wxID_EXIT, wxT("Exit"));

    local forms_menu = wx.wxMenu();
<xsl:for-each select="formulare/formular[@applicationid=$ApplicationID]">
<xsl:variable name="tempFormularName" select="@name"/>
<xsl:variable name="FormularName">
	<xsl:call-template name="SubstringReplace">
		<xsl:with-param name="stringIn">
	<xsl:call-template name="SubstringReplace">
		<xsl:with-param name="stringIn">
	<xsl:call-template name="SubstringReplace">
		<xsl:with-param name="stringIn">
			<xsl:value-of select="$tempFormularName"/>
		</xsl:with-param>
		<xsl:with-param name="substringIn" select="'-'"/>
		<xsl:with-param name="substringOut" select="''"/>
	</xsl:call-template>
		</xsl:with-param>
		<xsl:with-param name="substringIn" select="'>'"/>
		<xsl:with-param name="substringOut" select="''"/>
	</xsl:call-template>
		</xsl:with-param>
		<xsl:with-param name="substringIn" select="' '"/>
		<xsl:with-param name="substringOut" select="''"/>
	</xsl:call-template>
</xsl:variable>
    forms_menu:Append(self.ID_Create<xsl:value-of select="$FormularName"/>, wxT("Open <xsl:value-of select="$FormularName"/>"));
</xsl:for-each>

    self.m_perspectives_menu = wx.wxMenu();
    self.m_perspectives_menu:Append(self.ID_CreatePerspective, wxT("Create Perspective"));
    self.m_perspectives_menu:Append(self.ID_CopyPerspectiveCode, wxT("Copy Perspective Data To Clipboard"));
    self.m_perspectives_menu:AppendSeparator();
    self.m_perspectives_menu:Append(self.ID_FirstPerspective+0, wxT("Default Startup"));
    self.m_perspectives_menu:Append(self.ID_FirstPerspective+1, wxT("All Panes"));

    local help_menu = wx.wxMenu();
    help_menu:Append(wx.wxID_ABOUT, wxT("About..."));

    mb:Append(file_menu, wxT("File"));
    mb:Append(forms_menu, wxT("<xsl:value-of select="$ApplicationName"/>"));
    mb:Append(self.m_perspectives_menu, wxT("Perspectives"));
    mb:Append(help_menu, wxT("Help"));

    this:SetMenuBar(mb);

    this:CreateStatusBar();
    this:GetStatusBar():SetStatusText(wxT("Ready"));


    --// min size for the frame itself isn't completely done.
    --// see the end up wxAuiManager::Update() for the test
    --// code. For now, just hard code a frame minimum size
    this:SetMinSize(wx.wxSize(400,300));

    --// create some toolbars
    local tb1 = wx.wxToolBar(this, wx.wxID_ANY, wx.wxDefaultPosition, wx.wxDefaultSize,
                                   wx.wxTB_FLAT + wx.wxTB_NODIVIDER);
    tb1:SetToolBitmapSize(wx.wxSize(48,48));
    tb1:AddTool(101, wxT("Test"), wx.wxArtProvider.GetBitmap(wx.wxART_ERROR));
    tb1:AddSeparator();
    tb1:AddTool(102, wxT("Test"), wx.wxArtProvider.GetBitmap(wx.wxART_QUESTION));
    tb1:AddTool(103, wxT("Test"), wx.wxArtProvider.GetBitmap(wx.wxART_INFORMATION));
    tb1:AddTool(103, wxT("Test"), wx.wxArtProvider.GetBitmap(wx.wxART_WARNING));
    tb1:AddTool(103, wxT("Test"), wx.wxArtProvider.GetBitmap(wx.wxART_MISSING_IMAGE));
    tb1:Realize();


    --// make some default perspectives

    local perspective_all = self.m_mgr:SavePerspective();

    local i, count;
    local all_panes = self.m_mgr:GetAllPanes();
    count = all_panes:GetCount()
    for i = 0, count-1 do
        if ( all_panes:Item(i):IsToolbar() == false) then
            all_panes:Item(i):Hide();
        end
    end

    local perspective_default = self.m_mgr:SavePerspective();

    self.m_perspectives = wx.wxArrayString()
    self.m_perspectives:Add(perspective_default);
    self.m_perspectives:Add(perspective_all);

    --// "commit" all changes made to wxAuiManager
    self.m_mgr:Update();

    this:Connect(wx.wxEVT_ERASE_BACKGROUND, function(event) self:OnEraseBackground(event) end)
    this:Connect(wx.wxEVT_SIZE, function(event) self:OnSize(event) end)
    this:Connect(self.ID_CreateTree, wx.wxEVT_COMMAND_MENU_SELECTED, function(event) self:OnCreateTree(event) end)
    this:Connect(wx.wxID_EXIT, wx.wxEVT_COMMAND_MENU_SELECTED, function(event) self:OnExit(event) end)
    this:Connect(wx.wxID_ABOUT, wx.wxEVT_COMMAND_MENU_SELECTED, function(event) self:OnAbout(event) end)

<xsl:for-each select="formulare/formular[@applicationid=$ApplicationID]">
<xsl:variable name="tempFormularName" select="@name"/>
<xsl:variable name="FormularName">
	<xsl:call-template name="SubstringReplace">
		<xsl:with-param name="stringIn">
	<xsl:call-template name="SubstringReplace">
		<xsl:with-param name="stringIn">
	<xsl:call-template name="SubstringReplace">
		<xsl:with-param name="stringIn">
			<xsl:value-of select="$tempFormularName"/>
		</xsl:with-param>
		<xsl:with-param name="substringIn" select="'-'"/>
		<xsl:with-param name="substringOut" select="''"/>
	</xsl:call-template>
		</xsl:with-param>
		<xsl:with-param name="substringIn" select="'>'"/>
		<xsl:with-param name="substringOut" select="''"/>
	</xsl:call-template>
		</xsl:with-param>
		<xsl:with-param name="substringIn" select="' '"/>
		<xsl:with-param name="substringOut" select="''"/>
	</xsl:call-template>
</xsl:variable>
    this:Connect(self.ID_Create<xsl:value-of select="$FormularName"/>, wx.wxEVT_COMMAND_MENU_SELECTED, function(event) self:On<xsl:value-of select="$FormularName"/>(event) end)
</xsl:for-each>


    this:Connect(wxaui.wxEVT_AUI_PANE_CLOSE, function(event) self:OnPaneClose(event) end)
    this:Connect(wx.wxID_ANY, wxaui.wxEVT_COMMAND_AUINOTEBOOK_ALLOW_DND, function(event) self:OnAllowNotebookDnD(event) end)
    this:Connect(wx.wxID_ANY, wxaui.wxEVT_COMMAND_AUINOTEBOOK_PAGE_CLOSE, function(event) self:OnNotebookPageClose(event) end)

    return self
end

<xsl:for-each select="formulare/formular[@applicationid=$ApplicationID]">
<xsl:variable name="tempFormularName" select="@name"/>
<xsl:variable name="FormularName">
	<xsl:call-template name="SubstringReplace">
		<xsl:with-param name="stringIn">
	<xsl:call-template name="SubstringReplace">
		<xsl:with-param name="stringIn">
	<xsl:call-template name="SubstringReplace">
		<xsl:with-param name="stringIn">
			<xsl:value-of select="$tempFormularName"/>
		</xsl:with-param>
		<xsl:with-param name="substringIn" select="'-'"/>
		<xsl:with-param name="substringOut" select="''"/>
	</xsl:call-template>
		</xsl:with-param>
		<xsl:with-param name="substringIn" select="'>'"/>
		<xsl:with-param name="substringOut" select="''"/>
	</xsl:call-template>
		</xsl:with-param>
		<xsl:with-param name="substringIn" select="' '"/>
		<xsl:with-param name="substringOut" select="''"/>
	</xsl:call-template>
</xsl:variable>
function MyFrame:On<xsl:value-of select="$FormularName"/>(event)
-- Open <xsl:value-of select="$FormularName"/>
    <xsl:value-of select="$FormularName"/>
    if myPanel_<xsl:value-of select="$FormularName"/> == nil then
	    myPanel_<xsl:value-of select="$FormularName"/> = <xsl:value-of select="$FormularName"/>Panel:create(self, self, d3);

	    self.m_mgr:AddPane(myPanel_<xsl:value-of select="$FormularName"/>.this, wxaui.wxAuiPaneInfo():
                  Name(wxT("<xsl:value-of select="$FormularName"/>")):Caption(wxT("<xsl:value-of select="$FormularName"/>")):
                  Bottom():
                  CloseButton(true):MaximizeButton(true));

	    self.m_mgr:Update();
    end
end
</xsl:for-each>


function MyFrame:dtor()
    self.m_mgr:UnInit();
end

function MyFrame:GetDockArt()
    return self.m_mgr:GetArtProvider();
end

function MyFrame:DoUpdate()
    self.m_mgr:Update();
end

function MyFrame:OnEraseBackground(event)
    event:Skip();
end

function MyFrame:OnSize(event)
    event:Skip();
end

function MyFrame:OnSettings(event)
    --// show the settings pane, and float it
    local floating_pane = self.m_mgr:GetPane(wxT("settings")):Float():Show();

    if (floating_pane.floating_pos == wx.wxDefaultPosition) then
        floating_pane:FloatingPosition(self:GetStartPosition());
    end

    self.m_mgr:Update();
end

function MyFrame:OnGradient(event)
    local gradient = 0;

    local id = event:GetId()

    if      id == self.ID_NoGradient         then gradient = wxaui.wxAUI_GRADIENT_NONE;
    elseif  id == self.ID_VerticalGradient   then gradient = wxaui.wxAUI_GRADIENT_VERTICAL;
    elseif  id == self.ID_HorizontalGradient then gradient = wxaui.wxAUI_GRADIENT_HORIZONTAL;
    end

    self.m_mgr:GetArtProvider():SetMetric(wxaui.wxAUI_DOCKART_GRADIENT_TYPE, gradient);
    self.m_mgr:Update();
end

function MyFrame:OnManagerFlag(event)
    local flag = 0;
    local id = event:GetId()

--#if !defined(__WXMSW__) &amp;&amp; !defined(__WXMAC__) &amp;&amp; !defined(__WXGTK__)
if false then
    if (id == self.ID_TransparentDrag or
        id == self.ID_TransparentHint or
        id == self.ID_HintFade) then
        wx.wxMessageBox(wxT("This option is presently only available on wxGTK, wxMSW and wxMac"));
        return;
    end
end
--#endif

    if (id == self.ID_TransparentHint or
        id == self.ID_VenetianBlindsHint or
        id == self.ID_RectangleHint or
        id == self.ID_NoHint) then
        local flags = self.m_mgr:GetFlags();

        --[[hd.FIXME
        --flags &amp;= ~wxAUI_MGR_TRANSPARENT_HINT;
        --flags &amp;= ~wxAUI_MGR_VENETIAN_BLINDS_HINT;
        --flags &amp;= ~wxAUI_MGR_RECTANGLE_HINT;
        --]]
        flags = bit.band(flags, bit.bnot(wxaui.wxAUI_MGR_TRANSPARENT_HINT));
        flags = bit.band(flags, bit.bnot(wxaui.wxAUI_MGR_VENETIAN_BLINDS_HINT));
        flags = bit.band(flags, bit.bnot(wxaui.wxAUI_MGR_RECTANGLE_HINT));

        self.m_mgr:SetFlags(flags);
    end

    if      id == self.ID_AllowFloating      then flag = wxaui.wxAUI_MGR_ALLOW_FLOATING;
    elseif  id == self.ID_TransparentDrag    then flag = wxaui.wxAUI_MGR_TRANSPARENT_DRAG;
    elseif  id == self.ID_HintFade           then flag = wxaui.wxAUI_MGR_HINT_FADE;
    elseif  id == self.ID_NoVenetianFade     then flag = wxaui.wxAUI_MGR_NO_VENETIAN_BLINDS_FADE;
    elseif  id == self.ID_AllowActivePane    then flag = wxaui.wxAUI_MGR_ALLOW_ACTIVE_PANE;
    elseif  id == self.ID_TransparentHint    then flag = wxaui.wxAUI_MGR_TRANSPARENT_HINT;
    elseif  id == self.ID_VenetianBlindsHint then flag = wxaui.wxAUI_MGR_VENETIAN_BLINDS_HINT;
    elseif  id == self.ID_RectangleHint      then flag = wxaui.wxAUI_MGR_RECTANGLE_HINT;
    end

    if (flag) then
        --[[hd.FIXME
        m_mgr.SetFlags(m_mgr.GetFlags() ^ flag);
        --]]
        self.m_mgr:SetFlags(bit.bxor(self.m_mgr:GetFlags(), flag));
    end

    self.m_mgr:Update();
end


function MyFrame:OnNotebookFlag(event)
    local id = event:GetId();

    if (id == self.ID_NotebookNoCloseButton or
        id == self.ID_NotebookCloseButton or
        id == self.ID_NotebookCloseButtonAll or
        id == self.ID_NotebookCloseButtonActive) then
        --[[hd.FIXME
        m_notebook_style &amp;= ~(wxAUI_NB_CLOSE_BUTTON |
                              wxAUI_NB_CLOSE_ON_ACTIVE_TAB |
                              wxAUI_NB_CLOSE_ON_ALL_TABS);
        --]]
        self.m_notebook_style = bit.band(self.m_notebook_style, bit.bnot(wxaui.wxAUI_NB_CLOSE_BUTTON +
                              wxaui.wxAUI_NB_CLOSE_ON_ACTIVE_TAB +
                              wxaui.wxAUI_NB_CLOSE_ON_ALL_TABS));
    end

    --[[hd.FIXME
            case ID_NotebookNoCloseButton: break;
            case ID_NotebookCloseButton: m_notebook_style |= wxAUI_NB_CLOSE_BUTTON; break;
            case ID_NotebookCloseButtonAll: m_notebook_style |= wxAUI_NB_CLOSE_ON_ALL_TABS; break;
            case ID_NotebookCloseButtonActive: m_notebook_style |= wxAUI_NB_CLOSE_ON_ACTIVE_TAB; break;
    --]]
    if     id == self.ID_NotebookNoCloseButton     then
    elseif id == self.ID_NotebookCloseButton       then self.m_notebook_style = bit.bor(self.m_notebook_style, wxaui.wxAUI_NB_CLOSE_BUTTON);
    elseif id == self.ID_NotebookCloseButtonAll    then self.m_notebook_style = bit.bor(self.m_notebook_style, wxaui.wxAUI_NB_CLOSE_ON_ALL_TABS);
    elseif id == self.ID_NotebookCloseButtonActive then self.m_notebook_style = bit.bor(self.m_notebook_style, wxaui.wxAUI_NB_CLOSE_ON_ACTIVE_TAB);
    end

    --[[hd.FIXME
    if (id == ID_NotebookAllowTabMove)
    {
        m_notebook_style ^= wxAUI_NB_TAB_MOVE;
    }
    if (id == ID_NotebookAllowTabExternalMove)
    {
        m_notebook_style ^= wxAUI_NB_TAB_EXTERNAL_MOVE;
    }
     else if (id == ID_NotebookAllowTabSplit)
    {
        m_notebook_style ^= wxAUI_NB_TAB_SPLIT;
    }
     else if (id == ID_NotebookWindowList)
    {
        m_notebook_style ^= wxAUI_NB_WINDOWLIST_BUTTON;
    }
     else if (id == ID_NotebookScrollButtons)
    {
        m_notebook_style ^= wxAUI_NB_SCROLL_BUTTONS;
    }
     else if (id == ID_NotebookTabFixedWidth)
    {
        m_notebook_style ^= wxAUI_NB_TAB_FIXED_WIDTH;
    }
    --]]
    if (id == self.ID_NotebookAllowTabMove) then
        self.m_notebook_style = bit.bxor(self.m_notebook_style, wxaui.wxAUI_NB_TAB_MOVE);
    end
    if (id == self.ID_NotebookAllowTabExternalMove) then
        self.m_notebook_style = bit.bxor(self.m_notebook_style, wxaui.wxAUI_NB_TAB_EXTERNAL_MOVE);
    elseif (id == self.ID_NotebookAllowTabSplit) then
        self.m_notebook_style = bit.bxor(self.m_notebook_style, wxaui.wxAUI_NB_TAB_SPLIT);
     elseif (id == self.ID_NotebookWindowList) then
        self.m_notebook_style = bit.bxor(self.m_notebook_style, wxaui.wxAUI_NB_WINDOWLIST_BUTTON);
     elseif (id == self.ID_NotebookScrollButtons) then
        self.m_notebook_style = bit.bxor(self.m_notebook_style, wxaui.wxAUI_NB_SCROLL_BUTTONS);
     elseif (id == self.ID_NotebookTabFixedWidth) then
        self.m_notebook_style = bit.bxor(self.m_notebook_style, wxaui.wxAUI_NB_TAB_FIXED_WIDTH);
    end

    local i, count;
    local all_panes = self.m_mgr:GetAllPanes();
    count = all_panes:GetCount()
    for i = 0, count-1 do
        local pane = all_panes:Item(i);
        if (pane.window:IsKindOf(wx.wxClassInfo.FindClass("wxAuiNotebook"))) then
            local nb = pane.window:DynamicCast("wxAuiNotebook");

            if (id == self.ID_NotebookArtGloss) then
                nb:SetArtProvider(wxaui.wxAuiDefaultTabArt());
                self.m_notebook_theme = 0;
             elseif (id == self.ID_NotebookArtSimple) then
                nb:SetArtProvider(wxaui.wxAuiSimpleTabArt());
                self.m_notebook_theme = 1;
            end

            nb:SetWindowStyleFlag(self.m_notebook_style);
            nb:Refresh();
        end
    end

end


function MyFrame:OnUpdateUI(event)
    local flags = self.m_mgr:GetFlags();
    local id = event:GetId()

    if id == self.ID_NoGradient then
        --event.Check(m_mgr.GetArtProvider()->GetMetric(wxAUI_DOCKART_GRADIENT_TYPE) == wxAUI_GRADIENT_NONE);
        event:Check(self.m_mgr:GetArtProvider():GetMetric(wxaui.wxAUI_DOCKART_GRADIENT_TYPE) == wxaui.wxAUI_GRADIENT_NONE);
    elseif id == self.ID_VerticalGradient then
        --event.Check(m_mgr.GetArtProvider()->GetMetric(wxAUI_DOCKART_GRADIENT_TYPE) == wxAUI_GRADIENT_VERTICAL);
        event:Check(self.m_mgr:GetArtProvider():GetMetric(wxaui.wxAUI_DOCKART_GRADIENT_TYPE) == wxaui.wxAUI_GRADIENT_VERTICAL);
    elseif id == self.ID_HorizontalGradient then
        --event.Check(m_mgr.GetArtProvider()->GetMetric(wxAUI_DOCKART_GRADIENT_TYPE) == wxAUI_GRADIENT_HORIZONTAL);
        event:Check(self.m_mgr:GetArtProvider():GetMetric(wxaui.wxAUI_DOCKART_GRADIENT_TYPE) == wxaui.wxAUI_GRADIENT_HORIZONTAL);
    elseif id == self.ID_AllowFloating then
        --event.Check((flags &amp; wxAUI_MGR_ALLOW_FLOATING) != 0);
        event:Check(bit.band(flags, wxaui.wxAUI_MGR_ALLOW_FLOATING) ~= 0);
    elseif id == self.ID_TransparentDrag then
        --event.Check((flags &amp; wxAUI_MGR_TRANSPARENT_DRAG) != 0);
        event:Check(bit.band(flags, wxaui.wxAUI_MGR_TRANSPARENT_DRAG) ~= 0);
    elseif id == self.ID_TransparentHint then
        --event.Check((flags &amp; wxAUI_MGR_TRANSPARENT_HINT) != 0);
        event:Check(bit.band(flags, wxaui.wxAUI_MGR_TRANSPARENT_HINT) ~= 0);
    elseif id == self.ID_VenetianBlindsHint then
        --event.Check((flags &amp; wxAUI_MGR_VENETIAN_BLINDS_HINT) != 0);
        event:Check(bit.band(flags, wxaui.wxAUI_MGR_VENETIAN_BLINDS_HINT) ~= 0);
    elseif id == self.ID_RectangleHint then
        --event.Check((flags &amp; wxAUI_MGR_RECTANGLE_HINT) != 0);
        event:Check(bit.band(flags, wxaui.wxAUI_MGR_RECTANGLE_HINT) ~= 0);
    elseif id == self.ID_NoHint then
        --event.Check(((wxAUI_MGR_TRANSPARENT_HINT |
        --              wxAUI_MGR_VENETIAN_BLINDS_HINT |
        --              wxAUI_MGR_RECTANGLE_HINT) &amp; flags) == 0);
        event:Check(bit.band((wxaui.wxAUI_MGR_TRANSPARENT_HINT +
                          wxaui.wxAUI_MGR_VENETIAN_BLINDS_HINT +
                          wxaui.wxAUI_MGR_RECTANGLE_HINT), flags) == 0);
    elseif id == self.ID_HintFade then
        --event.Check((flags &amp; wxAUI_MGR_HINT_FADE) != 0);
        event:Check(bit.band(flags, wxaui.wxAUI_MGR_HINT_FADE) ~= 0);
    elseif id == self.ID_NoVenetianFade then
        --event.Check((flags &amp; wxAUI_MGR_NO_VENETIAN_BLINDS_FADE) != 0);
        event:Check(bit.band(flags, wxaui.wxAUI_MGR_NO_VENETIAN_BLINDS_FADE) ~= 0);

    elseif id == self.ID_NotebookNoCloseButton then
        --event.Check((m_notebook_style &amp; (wxAUI_NB_CLOSE_BUTTON|wxAUI_NB_CLOSE_ON_ALL_TABS|wxAUI_NB_CLOSE_ON_ACTIVE_TAB)) != 0);
        event:Check(bit.band(self.m_notebook_style, (wxaui.wxAUI_NB_CLOSE_BUTTON + wxaui.wxAUI_NB_CLOSE_ON_ALL_TABS + wxaui.wxAUI_NB_CLOSE_ON_ACTIVE_TAB)) ~= 0);
    elseif id == self.ID_NotebookCloseButton then
        --event.Check((m_notebook_style &amp; wxAUI_NB_CLOSE_BUTTON) != 0);
        event:Check(bit.band(self.m_notebook_style, wxaui.wxAUI_NB_CLOSE_BUTTON) ~= 0);
    elseif id == self.ID_NotebookCloseButtonAll then
        --event.Check((m_notebook_style &amp; wxAUI_NB_CLOSE_ON_ALL_TABS) != 0);
        event:Check(bit.band(self.m_notebook_style, wxaui.wxAUI_NB_CLOSE_ON_ALL_TABS) ~= 0);
    elseif id == self.ID_NotebookCloseButtonActive then
        --event.Check((m_notebook_style &amp; wxAUI_NB_CLOSE_ON_ACTIVE_TAB) != 0);
        event:Check(bit.band(self.m_notebook_style, wxaui.wxAUI_NB_CLOSE_ON_ACTIVE_TAB) ~= 0);
    elseif id == self.ID_NotebookAllowTabSplit then
        --event.Check((m_notebook_style &amp; wxAUI_NB_TAB_SPLIT) != 0);
        event:Check(bit.band(self.m_notebook_style, wxaui.wxAUI_NB_TAB_SPLIT) ~= 0);
    elseif id == self.ID_NotebookAllowTabMove then
        --event.Check((m_notebook_style &amp; wxAUI_NB_TAB_MOVE) != 0);
        event:Check(bit.band(self.m_notebook_style, wxaui.wxAUI_NB_TAB_MOVE) ~= 0);
    elseif id == self.ID_NotebookAllowTabExternalMove then
        --event.Check((m_notebook_style &amp; wxAUI_NB_TAB_EXTERNAL_MOVE) != 0);
        event:Check(bit.band(self.m_notebook_style, wxaui.wxAUI_NB_TAB_EXTERNAL_MOVE) ~= 0);
    elseif id == self.ID_NotebookScrollButtons then
        --event.Check((m_notebook_style &amp; wxAUI_NB_SCROLL_BUTTONS) != 0);
        event:Check(bit.band(self.m_notebook_style, wxaui.wxAUI_NB_SCROLL_BUTTONS) ~= 0);
    elseif id == self.ID_NotebookWindowList then
        --event.Check((m_notebook_style &amp; wxAUI_NB_WINDOWLIST_BUTTON) != 0);
        event:Check(bit.band(self.m_notebook_style, wxaui.wxAUI_NB_WINDOWLIST_BUTTON) ~= 0);
    elseif id == self.ID_NotebookTabFixedWidth then
        --event.Check((m_notebook_style &amp; wxAUI_NB_TAB_FIXED_WIDTH) != 0);
        event:Check(bit.band(self.m_notebook_style, wxaui.wxAUI_NB_TAB_FIXED_WIDTH) ~= 0);
    elseif id == self.ID_NotebookArtGloss then
        --event.Check(m_notebook_style == 0);
        event:Check(self.m_notebook_style == 0);
    elseif id == self.ID_NotebookArtSimple then
        --event.Check(m_notebook_style == 1);
        event:Check(self.m_notebook_style == 1);
    end
end

function MyFrame:OnPaneClose(evt)
    local this = self.this


<xsl:for-each select="formulare/formular[@applicationid=$ApplicationID]">
<xsl:variable name="tempFormularName" select="@name"/>
<xsl:variable name="FormularName">
	<xsl:call-template name="SubstringReplace">
		<xsl:with-param name="stringIn">
	<xsl:call-template name="SubstringReplace">
		<xsl:with-param name="stringIn">
	<xsl:call-template name="SubstringReplace">
		<xsl:with-param name="stringIn">
			<xsl:value-of select="$tempFormularName"/>
		</xsl:with-param>
		<xsl:with-param name="substringIn" select="'-'"/>
		<xsl:with-param name="substringOut" select="''"/>
	</xsl:call-template>
		</xsl:with-param>
		<xsl:with-param name="substringIn" select="'>'"/>
		<xsl:with-param name="substringOut" select="''"/>
	</xsl:call-template>
		</xsl:with-param>
		<xsl:with-param name="substringIn" select="' '"/>
		<xsl:with-param name="substringOut" select="''"/>
	</xsl:call-template>
</xsl:variable>
    if (evt:GetPane().name == wxT("<xsl:value-of select="$FormularName"/>")) then
	myPanel_<xsl:value-of select="$FormularName"/> = nil
    end
</xsl:for-each>
end

function MyFrame:OnCreatePerspective(event)
    local this = self.this
    local dlg = wx.wxTextEntryDialog(this, wxT("Enter a name for the new perspective:"),
                          wxT("wxAUI Test"));

    dlg:SetValue(string.format(wxT("Perspective %u"), (self.m_perspectives:GetCount() + 1)));
    if (dlg:ShowModal() ~= wx.wxID_OK) then
        return;
    end

    if (self.m_perspectives:GetCount() == 0) then
        self.m_perspectives_menu:AppendSeparator();
    end

    self.m_perspectives_menu:Append(self.ID_FirstPerspective + self.m_perspectives:GetCount(), dlg:GetValue());
    self.m_perspectives:Add(self.m_mgr:SavePerspective());
end

function MyFrame:OnCopyPerspectiveCode(evt)
    local s = self.m_mgr:SavePerspective();

--[[
#if wxUSE_CLIPBOARD
    if (wx.wxTheClipboard:Open()) then
        wx.wxTheClipboard:SetData(wx.wxTextDataObject(s));
        wx.wxTheClipboard:Close();
    end
--#endif
--]]
    local clipBoard = wx.wxClipboard.Get()
    if clipBoard and clipBoard:Open() then
        clipBoard:SetData(wx.wxTextDataObject(s))
        clipBoard:Close()
    end

end

function MyFrame:OnRestorePerspective(evt)
    self.m_mgr:LoadPerspective(self.m_perspectives:Item(evt:GetId() - self.ID_FirstPerspective));
end

function MyFrame:OnNotebookPageClose(evt)
    local this = self.this
    local ctrl = evt:GetEventObject():DynamicCast("wxAuiNotebook");
    if (ctrl:GetPage(evt:GetSelection()):IsKindOf(wx.wxClassInfo.FindClass("wxHtmlWindow"))) then
        local res = wx.wxMessageBox(wxT("Are you sure you want to close/hide this notebook page?"),
                       wxT("wxAUI"),
                       wx.wxYES_NO,
                       this);
        if (res ~= wx.wxYES) then
            evt:Veto();
        end
    end
end

function MyFrame:OnAllowNotebookDnD(evt)
    --// for the purpose of this test application, explicitly
    --// allow all noteboko drag and drop events
    evt:Allow();
end

local x=0
function MyFrame:GetStartPosition()
    x = x+20;
    local pt = self.this:ClientToScreen(wx.wxPoint(0,0));
    return wx.wxPoint(pt:GetX() + x, pt:GetY() + x);
end

function MyFrame:OnCreateTree(event)
    self.m_mgr:AddPane(self:CreateTreeCtrl(), wxaui.wxAuiPaneInfo():
                  Caption(wxT("Tree Control")):
                  Float():FloatingPosition(self:GetStartPosition()):
                  FloatingSize(wx.wxSize(150,300)));
    self.m_mgr:Update();
end

function MyFrame:OnCreateGrid(event)
    self.m_mgr:AddPane(self:CreateGrid(), wxaui.wxAuiPaneInfo():
                  Caption(wxT("Grid")):
                  Float():FloatingPosition(self:GetStartPosition()):
                  FloatingSize(wx.wxSize(300,200)));
    self.m_mgr:Update();
end

function MyFrame:OnCreateHTML(event)
    self.m_mgr:AddPane(self:CreateHTMLCtrl(), wxaui.wxAuiPaneInfo():
                  Caption(wxT("HTML Control")):
                  Float():FloatingPosition(self:GetStartPosition()):
                  FloatingSize(wx.wxSize(300,200)));
    self.m_mgr:Update();
end

function MyFrame:OnCreateNotebook(event)
    self.m_mgr:AddPane(self:CreateNotebook(), wxaui.wxAuiPaneInfo():
                  Caption(wxT("Notebook")):
                  Float():FloatingPosition(self:GetStartPosition()):
                  --//FloatingSize(300,200):
                  CloseButton(true):MaximizeButton(true));
    self.m_mgr:Update();
end

function MyFrame:OnCreateText(event)
    self.m_mgr:AddPane(self:CreateTextCtrl(), wxaui.wxAuiPaneInfo():
                  Caption(wxT("Text Control")):
                  Float():FloatingPosition(self:GetStartPosition()));
    self.m_mgr:Update();
end

function MyFrame:OnCreateSizeReport(event)
    self.m_mgr:AddPane(self:CreateSizeReportCtrl(), wxaui.wxAuiPaneInfo():
                  Caption(wxT("Client Size Reporter")):
                  Float():FloatingPosition(self:GetStartPosition()):
                  CloseButton(true):MaximizeButton(true));
    self.m_mgr:Update();
end

function MyFrame:OnChangeContentPane(event)
    self.m_mgr:GetPane(wxT("grid_content")):Show(event:GetId() == self.ID_GridContent);
    self.m_mgr:GetPane(wxT("text_content")):Show(event:GetId() == self.ID_TextContent);
    self.m_mgr:GetPane(wxT("tree_content")):Show(event:GetId() == self.ID_TreeContent);
    self.m_mgr:GetPane(wxT("sizereport_content")):Show(event:GetId() == self.ID_SizeReportContent);
    self.m_mgr:GetPane(wxT("html_content")):Show(event:GetId() == self.ID_HTMLContent);
    self.m_mgr:GetPane(wxT("notebook_content")):Show(event:GetId() == self.ID_NotebookContent);
    self.m_mgr:Update();
end

function MyFrame:OnTabAlignment(evt)
    local i, count;
    local all_panes = self.m_mgr:GetAllPanes();
    count = all_panes:GetCount()
    for i = 0, count-1 do
        local pane = all_panes:Item(i);
        if (pane.window:IsKindOf(wx.wxClassInfo.FindClass("wxAuiNotebook"))) then
            local nb = pane.window:DynamicCast("wxAuiNotebook");

            if (evt:GetId() == self.ID_NotebookAlignTop) then
                --nb->SetWindowStyleFlag(nb->GetWindowStyleFlag()^wxAUI_NB_BOTTOM|wxAUI_NB_TOP);
                nb:SetWindowStyleFlag(bit.bxor(nb:GetWindowStyleFlag(), wxaui.wxAUI_NB_BOTTOM+wxaui.wxAUI_NB_TOP));
            elseif (evt:GetId() == self.ID_NotebookAlignBottom) then
                --nb->SetWindowStyleFlag(nb->GetWindowStyleFlag()^wxAUI_NB_TOP|wxAUI_NB_BOTTOM);
               nb:SetWindowStyleFlag(bit.bxor(nb:GetWindowStyleFlag(), wxaui.wxAUI_NB_TOP+wxaui.wxAUI_NB_BOTTOM));
            end
            nb:Refresh();
        end
    end
end

function MyFrame:OnExit(event)
    local this = self.this

    self:DoneDb();

    self:dtor() --hd.
    this:Close(true);
end

function MyFrame:OnAbout(event)
    local this = self.this
    wx.wxMessageBox(wxT("wxAUI Demo\nAn advanced window management library for wxWidgets\n(c) Copyright 2005-2006, Kirix Corporation"), wxT("About wxAUI Demo"), wx.wxOK, this);
end

local n = 0;
function MyFrame:CreateTextCtrl(ctrl_text)
    local this = self.this

    local text="";
    if (ctrl_text and ctrl_text ~= "") then
        text = ctrl_text;
    else
        text = string.format(wxT("This is text box %d"), n+1); n=n+1
    end

    return wx.wxTextCtrl(this,wx.wxID_ANY, text,
                          wx.wxPoint(0,0), wx.wxSize(150,90),
                          wx.wxNO_BORDER + wx.wxTE_MULTILINE);
end


function MyFrame:CreateGrid()
    local this = self.this
    local grid = wx.wxGrid(this, wx.wxID_ANY,
                              wx.wxPoint(0,0),
                              wx.wxSize(150,250),
                              wx.wxNO_BORDER + wx.wxWANTS_CHARS);
    grid:CreateGrid(50, 20);
    return grid;
end

function MyFrame:CreateTreeCtrl()
    local this = self.this
    local tree = wx.wxTreeCtrl(this, wx.wxID_ANY,
                                      wx.wxPoint(0,0), wx.wxSize(160,250),
                                      wx.wxTR_DEFAULT_STYLE + wx.wxNO_BORDER);

    local imglist = wx.wxImageList(16, 16, true, 2);
    imglist:Add(wx.wxArtProvider.GetBitmap(wx.wxART_FOLDER, wx.wxART_OTHER, wx.wxSize(16,16)));
    imglist:Add(wx.wxArtProvider.GetBitmap(wx.wxART_NORMAL_FILE, wx.wxART_OTHER, wx.wxSize(16,16)));
    tree:AssignImageList(imglist);

    local root = tree:AddRoot(wxT("wxAUI Project"), 0);
    local items = {} --local items = wx.wxArrayTreeItemIds();

    items[#items+1] = tree:AppendItem(root, wxT("Item 1"), 0); --items:Add(tree:AppendItem(root, wxT("Item 1"), 0));
    items[#items+1] = tree:AppendItem(root, wxT("Item 2"), 0); --items:Add(tree:AppendItem(root, wxT("Item 2"), 0));
    items[#items+1] = tree:AppendItem(root, wxT("Item 3"), 0); --items:Add(tree:AppendItem(root, wxT("Item 3"), 0));
    items[#items+1] = tree:AppendItem(root, wxT("Item 4"), 0); --items:Add(tree:AppendItem(root, wxT("Item 4"), 0));
    items[#items+1] = tree:AppendItem(root, wxT("Item 5"), 0); --items:Add(tree:AppendItem(root, wxT("Item 5"), 0));

    local i, count;
    count = #items --items:Count()
    for i = 1, count do --for i = 0, count-1 do
        local id = items[i]; --local id = items:Item(i);
        tree:AppendItem(id, wxT("Subitem 1"), 1);
        tree:AppendItem(id, wxT("Subitem 2"), 1);
        tree:AppendItem(id, wxT("Subitem 3"), 1);
        tree:AppendItem(id, wxT("Subitem 4"), 1);
        tree:AppendItem(id, wxT("Subitem 5"), 1);
    end

    tree:Expand(root);

    return tree;
end

function MyFrame:CreateSizeReportCtrl(width, height)
    local this = self.this
    width = width or 0
    height = height or 0
    --local ctrl = wxSizeReportCtrl:create(this, wx.wxID_ANY,
    --                               wx.wxDefaultPosition,
    --                               wx.wxSize(width, height), self.m_mgr);
    --return ctrl.this;
    local ctrl = wxSizeReportCtrl(this, wx.wxID_ANY,
                                   wx.wxDefaultPosition,
                                   wx.wxSize(width, height), self.m_mgr);
    return ctrl;
end

function MyFrame:CreateHTMLCtrl(parent)
    local this = self.this
    if (not parent) then
        parent = this;
    end

    local ctrl = wx.wxHtmlWindow(parent, wx.wxID_ANY,
                                   wx.wxDefaultPosition,
                                   wx.wxSize(400,300));
    ctrl:SetPage(self:GetIntroText());
    return ctrl;
end

function MyFrame:CreateNotebook()
    local this = self.this
   --// create the notebook off-window to avoid flicker
   --local client_size = this:GetClientSize();
   local w,h = this:GetClientSizeWH();

   local ctrl = wxaui.wxAuiNotebook(this, wx.wxID_ANY,
                                    wx.wxPoint(w, h), --wx.wxPoint(client_size.x, client_size.y),
                                    wx.wxSize(430,200),
                                    self.m_notebook_style);

   local page_bmp = wx.wxArtProvider.GetBitmap(wx.wxART_NORMAL_FILE, wx.wxART_OTHER, wx.wxSize(16,16));

   ctrl:AddPage(self:CreateHTMLCtrl(ctrl), wxT("Welcome to wxAUI") , false, page_bmp);

   local panel = wx.wxPanel( ctrl, wx.wxID_ANY );
   local flex = wx.wxFlexGridSizer( 2,2 );
   flex:AddGrowableRow( 0 );
   flex:AddGrowableRow( 3 );
   flex:AddGrowableCol( 1 );
   flex:Add( 5,5 );   flex:Add( 5,5 );
   flex:Add( wx.wxStaticText( panel, -1, wxT("wxTextCtrl:") ), 0, wx.wxALL+wx.wxALIGN_CENTRE, 5 );
   flex:Add( wx.wxTextCtrl( panel, -1, wxT(""), wx.wxDefaultPosition, wx.wxSize(100,-1)),
                1, wx.wxALL+wx.wxALIGN_CENTRE, 5 );
   flex:Add( wx.wxStaticText( panel, -1, wxT("wxSpinCtrl:") ), 0, wx.wxALL+wx.wxALIGN_CENTRE, 5 );
   flex:Add( wx.wxSpinCtrl( panel, -1, wxT("5"), wx.wxDefaultPosition, wx.wxSize(100,-1),
                wx.wxSP_ARROW_KEYS, 5, 50, 5 ), 0, wx.wxALL+wx.wxALIGN_CENTRE, 5 );
   flex:Add( 5,5 );   flex:Add( 5,5 );
   panel:SetSizer( flex );
   ctrl:AddPage( panel, wxT("wxPanel"), false, page_bmp );


   ctrl:AddPage( wx.wxTextCtrl( ctrl, wx.wxID_ANY, wxT("Some text"),
                wx.wxDefaultPosition, wx.wxDefaultSize, wx.wxTE_MULTILINE+wx.wxNO_BORDER) , wxT("wxTextCtrl 1"), false, page_bmp );

   ctrl:AddPage( wx.wxTextCtrl( ctrl, wx.wxID_ANY, wxT("Some more text"),
                wx.wxDefaultPosition, wx.wxDefaultSize, wx.wxTE_MULTILINE+wx.wxNO_BORDER) , wxT("wxTextCtrl 2") );

   ctrl:AddPage( wx.wxTextCtrl( ctrl, wx.wxID_ANY, wxT("Some more text"),
                wx.wxDefaultPosition, wx.wxDefaultSize, wx.wxTE_MULTILINE+wx.wxNO_BORDER) , wxT("wxTextCtrl 3") );

   ctrl:AddPage( wx.wxTextCtrl( ctrl, wx.wxID_ANY, wxT("Some more text"),
                wx.wxDefaultPosition, wx.wxDefaultSize, wx.wxTE_MULTILINE+wx.wxNO_BORDER) , wxT("wxTextCtrl 4") );

   ctrl:AddPage( wx.wxTextCtrl( ctrl, wx.wxID_ANY, wxT("Some more text"),
                wx.wxDefaultPosition, wx.wxDefaultSize, wx.wxTE_MULTILINE+wx.wxNO_BORDER) , wxT("wxTextCtrl 5") );

   ctrl:AddPage( wx.wxTextCtrl( ctrl, wx.wxID_ANY, wxT("Some more text"),
                wx.wxDefaultPosition, wx.wxDefaultSize, wx.wxTE_MULTILINE+wx.wxNO_BORDER) , wxT("wxTextCtrl 6") );

   ctrl:AddPage( wx.wxTextCtrl( ctrl, wx.wxID_ANY, wxT("Some more text"),
                wx.wxDefaultPosition, wx.wxDefaultSize, wx.wxTE_MULTILINE+wx.wxNO_BORDER) , wxT("wxTextCtrl 7 (longer title)") );

   ctrl:AddPage( wx.wxTextCtrl( ctrl, wx.wxID_ANY, wxT("Some more text"),
                wx.wxDefaultPosition, wx.wxDefaultSize, wx.wxTE_MULTILINE+wx.wxNO_BORDER) , wxT("wxTextCtrl 8") );

   return ctrl;
end


function MyFrame:GetIntroText()
    local text = [[
        &lt;html&gt;&lt;body&gt;
        &lt;h3&gt;Welcome to wxAUI&lt;/h3&gt;
        &lt;br/&gt;&lt;b&gt;Overview&lt;/b&gt;&lt;br/&gt;
        &lt;p&gt;wxAUI is an Advanced User Interface library for the wxWidgets toolkit
        that allows developers to create high-quality, cross-platform user
        interfaces quickly and easily.&lt;/p&gt;
        &lt;p&gt;&lt;b&gt;Features&lt;/b&gt;&lt;/p&gt;
        &lt;p&gt;With wxAUI, developers can create application frameworks with:&lt;/p&gt;
        &lt;ul&gt;
        &lt;li&gt;Native, dockable floating frames&lt;/li&gt;
        &lt;li&gt;Perspective saving and loading&lt;/li&gt;
        &lt;li&gt;Native toolbars incorporating real-time, &amp;quot;spring-loaded&amp;quot; dragging&lt;/li&gt;
        &lt;li&gt;Customizable floating/docking behavior&lt;/li&gt;
        &lt;li&gt;Completely customizable look-and-feel&lt;/li&gt;
        &lt;li&gt;Optional transparent window effects (while dragging or docking)&lt;/li&gt;
        &lt;li&gt;Splittable notebook control&lt;/li&gt;
        &lt;/ul&gt;
        &lt;p&gt;&lt;b&gt;What's new in 0.9.3?&lt;/b&gt;&lt;/p&gt;
        &lt;p&gt;wxAUI 0.9.3, which is now bundled with wxWidgets, adds the following features:
        &lt;ul&gt;
        &lt;li&gt;New wxAuiNotebook class, a dynamic splittable notebook control&lt;/li&gt;
        &lt;li&gt;New wxAuiMDI* classes, a tab-based MDI and drop-in replacement for classic MDI&lt;/li&gt;
        &lt;li&gt;Maximize/Restore buttons implemented&lt;/li&gt;
        &lt;li&gt;Better hinting with wxGTK&lt;/li&gt;
        &lt;li&gt;Class rename.  'wxAui' is now the standard class prefix for all wxAUI classes&lt;/li&gt;
        &lt;li&gt;Lots of bug fixes&lt;/li&gt;
        &lt;/ul&gt;
        &lt;p&gt;&lt;b&gt;What's new in 0.9.2?&lt;/b&gt;&lt;/p&gt;
        &lt;p&gt;The following features/fixes have been added since the last version of wxAUI:&lt;/p&gt;
        &lt;ul&gt;
        &lt;li&gt;Support for wxMac&lt;/li&gt;
        &lt;li&gt;Updates for wxWidgets 2.6.3&lt;/li&gt;
        &lt;li&gt;Fix to pass more unused events through&lt;/li&gt;
        &lt;li&gt;Fix to allow floating windows to receive idle events&lt;/li&gt;
        &lt;li&gt;Fix for minimizing/maximizing problem with transparent hint pane&lt;/li&gt;
        &lt;li&gt;Fix to not paint empty hint rectangles&lt;/li&gt;
        &lt;li&gt;Fix for 64-bit compilation&lt;/li&gt;
        &lt;/ul&gt;
        &lt;p&gt;&lt;b&gt;What changed in 0.9.1?&lt;/b&gt;&lt;/p&gt;
        &lt;p&gt;The following features/fixes were added in wxAUI 0.9.1:&lt;/p&gt;
        &lt;ul&gt;
        &lt;li&gt;Support for MDI frames&lt;/li&gt;
        &lt;li&gt;Gradient captions option&lt;/li&gt;
        &lt;li&gt;Active/Inactive panes option&lt;/li&gt;
        &lt;li&gt;Fix for screen artifacts/paint problems&lt;/li&gt;
        &lt;li&gt;Fix for hiding/showing floated window problem&lt;/li&gt;
        &lt;li&gt;Fix for floating pane sizing problem&lt;/li&gt;
        &lt;li&gt;Fix for drop position problem when dragging around center pane margins&lt;/li&gt;
        &lt;li&gt;LF-only text file formatting for source code&lt;/li&gt;
        &lt;/ul&gt;
        &lt;p&gt;See README.txt for more information.&lt;/p&gt;
        &lt;/body&gt;&lt;/html&gt;    ]]

    return text;
end





function MyApp.OnInit()
    myframe = MyFrame:create()
    local frame = myframe.this
    wx.wxGetApp():SetTopWindow(frame);
    frame:Show();
    return true;
end

MyApp.OnInit()


-- Call wx.wxGetApp():MainLoop() last to start the wxWidgets event loop,
-- otherwise the wxLua program will exit immediately.
-- Does nothing if running from wxLua, wxLuaFreeze, or wxLuaEdit since the
-- MainLoop is already running or will be started by the C++ program.
wx.wxGetApp():MainLoop()
</exsl:document>
</xsl:template>
</xsl:stylesheet>
